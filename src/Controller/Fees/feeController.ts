import { Request, Response } from 'express';
import FeeStructure from '../../Model/feeModel';

/**
 * POST /api/fees - Create a new fee
 */
export const createFee = async (req: Request, res: Response): Promise<void> => {
  try {
    const {
      feeName,
      feeType,
      value,
      appliesTo,
      scope = 'GLOBAL',
      isActive = true,
    } = req.body;

    // Validate required fields
    if (!feeName || !feeType || value === undefined || !appliesTo) {
      res.status(400).json({
        success: false,
        message: 'Required fields: feeName, feeType, value, appliesTo',
      });
      return;
    }

    // Validate feeType
    if (!['FLAT', 'PERCENTAGE', 'COMMISSION'].includes(feeType)) {
      res.status(400).json({
        success: false,
        message: 'feeType must be FLAT, PERCENTAGE, or COMMISSION',
      });
      return;
    }

    // Validate appliesTo
    if (!['TRAVELLER', 'HOST', 'BOTH'].includes(appliesTo)) {
      res.status(400).json({
        success: false,
        message: 'appliesTo must be TRAVELLER, HOST, or BOTH',
      });
      return;
    }

    // Validate scope
    if (!['GLOBAL', 'STORY'].includes(scope)) {
      res.status(400).json({
        success: false,
        message: 'scope must be GLOBAL or STORY',
      });
      return;
    }

    // Validate value
    if (typeof value !== 'number' || value < 0) {
      res.status(400).json({
        success: false,
        message: 'value must be a non-negative number',
      });
      return;
    }

    // Create new fee (feeId will be auto-generated by pre-save hook)
    const newFee = new FeeStructure({
      feeName,
      feeType,
      value,
      appliesTo,
      scope,
      isActive,
    });

    const savedFee = await newFee.save();

    res.status(201).json({
      success: true,
      message: 'Fee created successfully',
      data: savedFee,
    });
  } catch (error: any) {
    console.error('Error creating fee:', error);

    // Handle duplicate key errors
    if (error?.code === 11000) {
      res.status(409).json({
        success: false,
        message: 'A fee with this ID already exists. Please retry.',
      });
      return;
    }

    res.status(500).json({
      success: false,
      message: error.message || 'Internal server error',
    });
  }
};

/**
 * GET /api/fees - Fetch all fees with optional filters
 */
export const getAllFees = async (
  req: Request,
  res: Response
): Promise<void> => {
  try {
    const { scope, appliesTo, feeType, isActive } = req.query;

    // Build filter object
    const filter: any = {};

    if (scope) {
      if (!['GLOBAL', 'STORY'].includes(scope as string)) {
        res.status(400).json({
          success: false,
          message: 'scope must be GLOBAL or STORY',
        });
        return;
      }
      filter.scope = scope;
    }

    if (appliesTo) {
      if (!['TRAVELLER', 'HOST', 'BOTH'].includes(appliesTo as string)) {
        res.status(400).json({
          success: false,
          message: 'appliesTo must be TRAVELLER, HOST, or BOTH',
        });
        return;
      }
      filter.appliesTo = appliesTo;
    }

    if (feeType) {
      if (!['FLAT', 'PERCENTAGE', 'COMMISSION'].includes(feeType as string)) {
        res.status(400).json({
          success: false,
          message: 'feeType must be FLAT, PERCENTAGE, or COMMISSION',
        });
        return;
      }
      filter.feeType = feeType;
    }

    if (isActive !== undefined) {
      filter.isActive = isActive === 'true';
    }

    const fees = await FeeStructure.find(filter).sort({ createdAt: -1 });

    res.status(200).json({
      success: true,
      message: 'Fees retrieved successfully',
      data: fees,
      count: fees.length,
    });
  } catch (error: any) {
    console.error('Error fetching fees:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Internal server error',
    });
  }
};

/**
 * PATCH /api/fees/:feeId - Update an existing fee
 */
export const updateFee = async (
  req: Request<{ feeId: string }>,
  res: Response
): Promise<void> => {
  try {
    const { feeId } = req.params;
    const updates = req.body;

    // Prevent feeId from being updated
    if (updates.feeId) {
      res.status(400).json({
        success: false,
        message: 'feeId cannot be updated',
      });
      return;
    }

    // Validate feeType if provided
    if (
      updates.feeType &&
      !['FLAT', 'PERCENTAGE', 'COMMISSION'].includes(updates.feeType)
    ) {
      res.status(400).json({
        success: false,
        message: 'feeType must be FLAT, PERCENTAGE, or COMMISSION',
      });
      return;
    }

    // Validate appliesTo if provided
    if (
      updates.appliesTo &&
      !['TRAVELLER', 'HOST', 'BOTH'].includes(updates.appliesTo)
    ) {
      res.status(400).json({
        success: false,
        message: 'appliesTo must be TRAVELLER, HOST, or BOTH',
      });
      return;
    }

    // Validate scope if provided
    if (updates.scope && !['GLOBAL', 'STORY'].includes(updates.scope)) {
      res.status(400).json({
        success: false,
        message: 'scope must be GLOBAL or STORY',
      });
      return;
    }

    // Validate value if provided
    if (
      updates.value !== undefined &&
      (typeof updates.value !== 'number' || updates.value < 0)
    ) {
      res.status(400).json({
        success: false,
        message: 'value must be a non-negative number',
      });
      return;
    }

    // Find the existing fee
    const existingFee = await FeeStructure.findOne({ feeId });

    if (!existingFee) {
      res.status(404).json({
        success: false,
        message: 'Fee not found',
      });
      return;
    }

    // Update the fee
    const updatedFee = await FeeStructure.findOneAndUpdate(
      { feeId },
      { $set: updates },
      { new: true, runValidators: true }
    );

    res.status(200).json({
      success: true,
      message: 'Fee updated successfully',
      data: updatedFee,
    });
  } catch (error: any) {
    console.error('Error updating fee:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Internal server error',
    });
  }
};
